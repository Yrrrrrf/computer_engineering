# [Programming Paradigms](https://view.genial.ly/600b6a2789906e0ce6bbbbf2/horizontal-infographic-lists-paradigmas-de-programacion)
Are the fundamental principles used when developing software. They are best described as **fundamentally different programming styles**, which in turn result in differently structured software code.

The classic concept is **[[#Imperative Programming]]**, where the **source code** clearly defines which steps a program has to complete and in what order.
On the other hand, the **[[#Declarative Programming]]** principle involves describing only what software should do (i.e. only the result and not the individual steps).

![[Programming Paradigms.png]]

### Imperative Programming

The first programming languages – and correspondingly, the first computer programs – were based entirely on this classic approach, which provides a controlled sequence of specific commands (the name comes from the Latin _imperare_ meaning “command”) or instructions. Imperative programming focuses in part on working **as closely as possible with the system**. The resulting program code is therefore easy to understand but also very extensive.

Within this approach, there are three important subordinate methods for writing and structuring software code: **[[structured programming|structured]]**, **[[procedural programming|procedural]]**, and **[[modular programming|modular]]** programming. With this structuring pillars we're able to "built" the [[object oriented programming]] paradigm, that modelates entities on a model & the relations between they.

**Advantajes**
- Many programming languages based on the imperative programming paradigm are in use today. On the one hand, this is because the approach is the **original form of programming**. On the other hand, despite the existence of alternative models, the imperative paradigm still has some practical advantages.
- The languages are **relatively easy to learn**, as the code can be read like a step-by-step instruction. Therefore, programmers normally learn an imperative language first as part of their training.
- **Easy legibility** is a crucial factor in day-to-day operations. Ultimately, maintenance and optimization of applications should not be linked to a specific person; different employees should be able to do it without too much difficulty even if they haven’t written the code from scratch themselves.
- One disadvantage of procedural programming is that for more complex problems to be solved, the amount of code quickly starts to grow. It remains easy to read but **becomes confusing due to its volume**.
- Execution is not clearly delineated from the programming as it is in the declarative style, therefore, subsequent interventions can produce unwanted errors. Extensions are also more difficult to implement in pure imperative code – unlike in the declarative paradigm, where there are methods that can be used to add them separately.

### Declarative Programming

The fundamental principle of declarative programming is that it **describes the desired end result**. Thus, it is primarily about the “what” – the result – rather than the **“how” – the steps towards the solution** – as is the case with imperative programming. As a consequence, because of the **high level of abstraction,** the code generated by declarative programming is much more difficult to understand. And it is short and precise.

Since declarative programming does not specifically describe the “how” but works at a very high level of abstraction, the programming paradigm also leaves **room for optimization**. If a better implementation procedure is developed, the integrated algorithm can identify and use it. This makes the paradigm futureproof. The procedure for how the result is to be achieved does not have to be set in stone when writing the code.

The two most important methods in the declarative programming paradigm are **[[functional programming|functional]]** and **[[logic programming|logic]]** programming.

**Advantajes**
Is characterized by a **high level of abstraction**. This enables developers to represent complex programs in a compressed form. But the more sophisticated the application, the greater the danger that the code becomes so convoluted that it can only be read by the developer who originally wrote it. For companies that want to be able to maintain and develop applications without having to rely on a single person’s knowledge, this presents a challenge. External developers have to carefully read and work out the declarative code until they understand the structure and have solved any problems.

However, the level of abstraction in declarative programming also offers advantages. Because implementation is clearly delineated from the system using an algorithm, **maintenance can be performed independently of application development**. Interruptions of day-to-day operations are reduced to a minimum. At the same time, optimization is easier because the algorithm used allows new methods to be integrated. One disadvantage of algorithm use is that this kind of formulaic solution is often insufficiently equipped to deal with specific characteristics of individual applications.

Not so much a disadvantage as a **challenge is the conceptual model** of declarative programming. Thinking in terms of solution states contradicts natural human thought processes. People tend to think in terms of processes moving towards a goal rather than starting from a goal and working backward. This requires developers to rethink and accustom themselves to the concept, which can initially slow down problem-solving. However, once the new mindset has been learned, the declarative approach can capitalize on its strengths.

Another advantage of development starting from the description of the problem is that teams can outline solution models rapidly. Ultimately, specific programming of the implementation can take place later. The declarative style is thus well suited for **prototyping** in [agile software development](https://www.ionos.com/digitalguide/websites/web-development/agile-software-development-about/ "Agile software development about").
